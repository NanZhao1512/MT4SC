\begin{document}
\subsubsection{Payroll}

Payroll\footnote{\url{https://github.com/fforbeck/Payroll-SmartContract/tree/master/contracts}} allows employers to pay salaries to their employees. The inputs of payroll include the employee's \textit{salary} and the payment \textit{duration}. The output state variable is the employee's \textit{balance}. Possible user behaviors include: \(u_1\) = set the employee's salary; \(u_2\) = set the payment duration; and \(u_3\) = pay salaries. Only \textit{Rule 1} can be applied to identify MRs for Payroll. For example, given \(TC_s = ([u1, u2, u3], (salary, Duration))\), an MR can be defined as: increasing the value of \textit{salary} can lead to the corresponding increase of \textit{balance}.

\subsubsection{Auction}

Auction\footnote{\url{https://github.com/brynbellomy/solidity-auction}} enables users to engage in competitive bidding within a predetermined time frame. The inputs include the duration of the auction (\textit{biddingTime}) and the bid \textit{amount} placed by the user. The output state includes the user's current \textit{balance} and the highest bid that has been recorded (\textit{highestBid}). Possible user behaviors include: \(u_1\) = initiation of an auction and \(u_2\) = the placement of a bid. Only \textit{Rule 2} can be applied to identify MRs for Auction. For example, given \(TC_s = ([u_1, u_2], (biddingTime, amount))\), where \(TD(U) = \text{False}\), an MR can be defined as: incrementing the \textit{amount} should lead to an adjustment in \textit{balance} and \textit{highestBid} accordingly.

\subsubsection{Ballot}

The Ballot\footnote{\url{https://github.com/UnitedCrowd/voting-contract}} contract enables users to participate in a voting process. Its inputs include the voting period (\textit{votingTime}) and the user's selected candidate (\textit{candidateId}). The output state variables are the total number of votes for each candidate (\(votes\)) and the leading candidate (\textit{leadCand}). Possible user behaviors include: \(u_1\) = initiate a voting session; \(u_2\) = register as a voter; \(u_3\) = casting a vote; and \(u_4\) = view vote results. Both \textit{Rule 1} and \textit{Rule 2} can be applied to identify MRs for Ballot. For example, given \(TC_s = ([u_1, u_2], (votingTime, candidateId))\), where \(TD(U) = \text{True}\), we can define an MR using \textit{Rule 1} as: choosing the different \textit{candidateId} should lead to an adjustment in \textit{leadCand} accordingly. Another example MR based on \textit{Rule 2} is: given \(TC_s = ([u_3, u_4], (votingTime, candidateId))\), where \(TD(U) = \text{False}\), choosing the different \textit{candidateId} should lead to an adjustment in \textit{leadCand} accordingly.

\subsubsection{Insurance}

The Insurance\footnote{\url{https://github.com/validitylabs/ethCarInsurance}} contract facilitates insurance purchase. Its inputs consist of insurance ID (\textit{id}), insurance purchase \textit{price}, and insurance \textit{compensation} amount. The output state is the user account \textit{balance}. Possible user behaviors include: \(u_1\) = purchase insurance; \(u_2\) = submit claim; \(u_3\) = receive payout; and \(u_4\) = view balance. We can apply \textit{Rules 2-4} to identify MRs for Insurance. One example MR based on \textit{Rule 2} is: given \(TC_s = ([u2,u3,u4],(id, price, compensation)]\), where \(TD(U) = \text{False}\), increasing the value of \textit{compensation} can lead to the corresponding increase of \textit{balance}. For \textit{Rule 3}, an MR can be defined as: changing the order of \((U_s)\) will not change the value of \textit{balance}. We can also define an MR using \textit{Rule 4} as follows: changing the order of \((U_s)\) and the value of \textit{compensation} should result in a different value of \textit{balance}.

\subsubsection{SmartID}

The SmartID\footnote{\url{https://github.com/SmartIdentity/smartId-contracts}} contract is structured to streamline the creation and verification of digital identities. Its required inputs are the user's own identity (\textit{owner}) and specific identity \textit{attributes}. The output state includes a boolean value representing the verification status of the identity information (\textit{result}) and a unique identifier for the user, such as a user's \textit{address}. Possible user behaviors include: \(u_1\) = appending an element to an array of addresses; \(u_2\) = verifying if an array contains all elements of another; \(u_3\) = finding unique elements between two arrays; \(u_4\) = reversing the order of the elements within an array. An example MR based on \textit{Rule 4} is: given \(TC_s = ([u2,u3,u4],(owner, attributes))\), where (\(TD(U_s) = \text{False}\)), if we permute the order of the user behaviors (\(u_2, u_3, u_4\)) and alter the \textit{attributes} while keeping the same \textit{owner}, the output parameter \textit{result} should change to reflect the new \textit{attributes}, despite the change in the order of actions.

\subsubsection{Cryptofin}

The Cryptofin\footnote{\url{https://github.com/cryptofinlabs/cryptofin-solidity}} contract is designed to perform various operations on arrays of addresses. Inputs for this contract include \textit{A} and \textit{B} for different sets of address arrays, \textit{a} for a single address element, and \textit{index} for specifying a position within an array. The output state is a boolean or array \textit{result}, indicating the success or outcome of the applied function. Possible user behaviors include: \(u_1\) = appending an element to an array of addresses; \(u_2\) = verifying if an array contains all elements of another; \(u_3\) = finding unique elements between two arrays; \(u_4\) = reversing the order of the elements within an array; \(u_5\) = checking for duplicate elements in an array. \textit{Rules 2-4} can be used to identify MRs for Cryptofin. An example MR based on \textit{Rule 2} is: given \(TC_s = ([u_1,u_4,u_5],(A, a))\), where \(TD(U_s) = \text{False}\), reversing the order of array \(A\) with \textit{sReverse()} (\(u_4\)) after appending an element (\(u_1\)) should not affect the outcome of \textit{hasDuplicate()} (\(u_5\)), as the presence of duplicates is independent of element order. An example MR based on \textit{Rule 3} is as follows: changing the order of the operations (\(u_1, u_4, u_5\)) to (\(u_5, u_1, u_4\)) should result in the same output for \textit{hasDuplicate()} (\(u_5\)), as the operation of appending an element (\(u_1\)) and reversing (\(u_4\)) do not create or eliminate duplicates. For \textit{Rule 4}, an example MR is: if an element is appended to array \(A\) (\(u_1\)) and later the array is checked for equality with array \(B\) (\(u_6\)), the result should differ from the equality check before the append operation, assuming \(B\) remains unchanged.

\subsubsection{SkinCoin}

The SkinCoin\footnote{\url{https://github.com/Steamtradenet/smart-contract}} contract is tailored for virtual asset management, specifically for buying and selling game skins. Inputs for this contract include the skin ID (\textit{id}), sale \textit{price}, buyer's and seller's addresses (\textit{buyerAdd} and \textit{sellerAdd}). The output state is the SkinCoin \textit{balance} of the user. Possible user behaviors include: \(u_1\) = listing a skin for sale; \(u_2\) = buying a skin; and \(u_3\) = checking account balance. \textit{Rules 1-3} can be applied to identify MRs for SkinCoin. For example, we can define the following MR based on \textit{Rule 1}: given a test case \(TC_s = ([u_1,u_2,u_3],(id, price, buyerAdd, sellerAdd))\), where \(TD(U) = \text{False}\), listing the same skin for sale with a different price should only affect the sale price, not the functionality of buying the skin or checking the balance. An example MR based on \textit{Rule 2} is: if the sale price (\textit{price}) is increased, then after a successful purchase, the seller's \textit{balance} should increase correspondingly. An example MR based on \textit{Rule 3} is: changing the order of \((U_s)\) and buying a skin should not affect the final \textit{balance}, assuming no other transactions have taken place meanwhile.

\subsubsection{Funding}

The Funding\footnote{\url{https://github.com/giobart/EtherCrowdfunding}} contract is designed to manage and facilitate funding campaigns for projects. Inputs for the contract include a campaign ID (\textit{id}), a funding target amount (\textit{amount}), and the contribution amount (\textit{contribution}). The output state is the campaign funds raised (\textit{fundsRaised}) and the contributor's balance (\textit{contributorBalance}). Possible user behaviors include: \(u_1\) = initiating a crowdfunding campaign; \(u_2\) = contributing to a campaign; \(u_3\) = checking funds raised; and \(u_4\) = withdrawing contributions. All four rules can be used to identify MRs for Funding. For example, given a test case \(TC_s = ([u_2,u_3,u_4],(id, amount, contribution))\), where \(TD(U) = \text{False}\), the following MR can be defined based on \textit{Rule 1}: contributing the same amount to two different campaigns should not affect the ability to check the funds raised or to withdraw contributions. An example MR using \textit{Rule 2} is: if (\textit{contribution}) is increased, then \textit{fundsRaised} should increase correspondingly. For \textit{Rule 3}, an example MR is: changing the order of \((U_s)\) should not affect the final state of \textit{fundsRaised}, assuming no external changes have occurred. For \textit{Rule 4}, an example MR is: when a contribution is made (\(u_2\)) and then withdrawn (\(u_4\)), these operations are repeated but with a different contribution amount, the final \textit{contributorBalance} should reflect the total contributions made, independent of the order of these actions.

\end{document}